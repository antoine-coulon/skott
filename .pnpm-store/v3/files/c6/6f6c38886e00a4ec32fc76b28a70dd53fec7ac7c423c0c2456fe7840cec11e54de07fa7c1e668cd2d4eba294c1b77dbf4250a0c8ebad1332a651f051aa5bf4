import { VertexDefinition, VertexId, VertexBody } from "./vertex.js";
export declare class DiGraph<Vertex extends VertexDefinition<VertexBody>> {
    #private;
    constructor();
    get isAcyclic(): boolean;
    toDict(): Record<VertexId, Vertex>;
    hasVertex(vertexId: VertexId): boolean;
    addVertex(vertex: Vertex): void;
    addVertices(...vertices: Vertex[]): void;
    deleteVertex(vertexId: VertexId): void;
    addEdge({ from, to }: {
        from: VertexId;
        to: VertexId;
    }): void;
    deleteEdge({ from, to }: {
        from: VertexId;
        to: VertexId;
    }): void;
    /**
     * This function updates the vertex's body with the provided value without
     * doing any merging with the previous value. If you want to preserve/update
     * values, check `mergeVertexBody` instead.
     * @example
     * updateVertexBody("Node1", {
     *    // body only contains this property "newProperty" now.
     *    newProperty: []
     * });
     *
     */
    updateVertexBody(vertexId: VertexId, body: Vertex["body"]): void;
    /**
     * This function lets you choose the way of merging the vertex's body
     * by providing a callback function with the corresponding vertex instance.
     * @example
     * mergeVertexBody("Node1", (nodeBody) => {
     *    // either by directly mutating the value
     *    nodeBody.someProperty.list[0] = {};
     *    // either by providing a new reference
     *    nodeBody.someProperty.list = newCollection.map(operation);
     * });
     */
    mergeVertexBody(vertexId: VertexId, mergeCallback: (vertex: Vertex["body"]) => void): void;
    /**
     * Allows top-to-bottom traversals by finding only the first relationship level
     * of children dependencies of the provided vertex.
     * @example
     * // given A --> B, A depends on B hence B is a children dependency of A
     * assert.deepEqual(graph.getChildren("A"), [VertexB]) // ok
     */
    getChildren(rootVertexId: VertexId): Vertex[];
    /**
     * Same as `getChildren()`, but doesn't stop at the first level hence deeply
     * collects all children dependencies in  a Depth-First Search manner.
     * Allows top-to-bottom traversals i.e: which nodes are dependencies of
     * the provided rootVertexId.
     */
    getDeepChildren(rootVertexId: VertexId): Generator<VertexId>;
    /**
     * Allows bottom-to-top traversals by finding only the first relationship level
     * of parent dependencies of the provided vertex.
     * @example
     * // given A --> B, A depends on B hence A is a parent dependency of B
     * assert.deepEqual(graph.getParents("B"), [VertexA]) // ok
     */
    getParents(rootVertexId: VertexId): Vertex[];
    /**
     * Same as `getParents()`, but doesn't stop at the first level hence deeply
     * collects all parent dependencies in a Depth-First Search manner.
     * Allows bottom-to-top traversals i.e: which nodes are depending on
     * the provided rootVertexId.
     */
    getDeepParents(rootVertexId: VertexId): Generator<VertexId>;
    /**
     * Returns `true` if atleast one circular dependency exists in the graph,
     * otherwise, returns `false`.
     * If you want to know precisely what are the circular dependencies and
     * know what vertices are involved, use `findCycles()` instead.
     */
    hasCycles({ maxDepth }?: {
        maxDepth: number;
    }): boolean;
    findCycles({ maxDepth }?: {
        maxDepth: number;
    }): VertexId[][];
    private limitCycleDetectionDepth;
    private collectRootAdjacencyLists;
    /**
     * This method is used to deeply find either all lower dependencies of a given
     * vertex or all its upper dependencies.
     */
    private findDeepDependencies;
    private keepUniqueVerticesPaths;
    /**
     * Once the cycle found, many vertices actually not involved in the cycle
     * might have been visited. To only keep vertices that are effectively involved
     * in the cyclic path, we must check that for any vertex there is an existing
     * path from its ancestor leading to the root node.
     */
    private backtrackVerticesInvolvedInCycle;
    private keepUniqueVertices;
}
