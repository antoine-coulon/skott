"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.unsafeStruct = exports.unsafeArray = exports.tuple = exports.tagged = exports.struct = exports.case = exports.array = exports.TaggedClass = exports.Class = void 0;
var Equal = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/data/Equal"));
var Hash = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/data/Hash"));
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
/**
 * @since 1.0.0
 */

const protoArr = /*#__PURE__*/(() => {
  const proto = {
    [Hash.symbol]() {
      return Hash.array(this);
    },
    [Equal.symbol](that) {
      if (Array.isArray(that) && this.length === that.length) {
        return this.every((v, i) => Equal.equals(v, that[i]));
      } else {
        return false;
      }
    }
  };
  return Object.setPrototypeOf(proto, Array.prototype);
})();
const protoStruct = /*#__PURE__*/(() => {
  const proto = {
    [Hash.symbol]() {
      return Hash.structure(this);
    },
    [Equal.symbol](that) {
      const selfKeys = Object.keys(this);
      const thatKeys = Object.keys(that);
      if (selfKeys.length !== thatKeys.length) {
        return false;
      }
      for (const key of selfKeys) {
        if (!(key in that && Equal.equals(this[key], that[key]))) {
          return false;
        }
      }
      return true;
    }
  };
  return Object.setPrototypeOf(proto, Object.prototype);
})();
/**
 * @category constructors
 * @since 1.0.0
 */
const struct = as => unsafeStruct(Object.assign({}, as));
/**
 * @category constructors
 * @since 1.0.0
 */
exports.struct = struct;
const unsafeStruct = as => Object.setPrototypeOf(as, protoStruct);
/**
 * @category constructors
 * @since 1.0.0
 */
exports.unsafeStruct = unsafeStruct;
const tuple = (...as) => unsafeArray(as);
/**
 * @category constructors
 * @since 1.0.0
 */
exports.tuple = tuple;
const array = as => unsafeArray(as.slice(0));
/**
 * @category constructors
 * @since 1.0.0
 */
exports.array = array;
const unsafeArray = as => Object.setPrototypeOf(as, protoArr);
exports.unsafeArray = unsafeArray;
const _case = () => args => args === undefined ? struct({}) : struct(args);
exports.case = _case;
/**
 * Provides a tagged constructor for the specified `Case`.
 *
 * @since 1.0.0
 * @category constructors
 */
const tagged = tag =>
// @ts-expect-error
args => args === undefined ? struct({
  _tag: tag
}) : struct({
  ...args,
  _tag: tag
});
/**
 * Provides a Tagged constructor for a Case Class.
 *
 * @since 1.0.0
 * @category constructors
 */
exports.tagged = tagged;
const TaggedClass = tag => () => {
  class Base extends Class() {
    constructor() {
      super(...arguments);
      this._tag = tag;
    }
  }
  return Base;
};
/**
 * Provides a constructor for a Case Class.
 *
 * @since 1.0.0
 * @category constructors
 */
exports.TaggedClass = TaggedClass;
const Class = () => {
  class Base {
    constructor(args) {
      Object.assign(this, args);
    }
    [Hash.symbol]() {
      return Hash.structure(this);
    }
    [Equal.symbol](that) {
      const selfKeys = Object.keys(this);
      const thatKeys = Object.keys(that);
      if (selfKeys.length !== thatKeys.length) {
        return false;
      }
      for (const key of selfKeys) {
        if (!(key in that && Equal.equals(this[key], that[key]))) {
          return false;
        }
      }
      return true;
    }
  }
  return Base;
};
exports.Class = Class;
//# sourceMappingURL=Data.js.map