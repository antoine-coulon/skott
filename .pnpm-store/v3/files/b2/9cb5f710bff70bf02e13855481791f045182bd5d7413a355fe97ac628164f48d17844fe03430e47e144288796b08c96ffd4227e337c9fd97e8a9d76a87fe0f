"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.zipWithIndexOffset = exports.zipWithIndex = exports.zipWith = exports.zipAllWith = exports.zipAll = exports.zip = exports.unzip = exports.unsafeLast = exports.unsafeHead = exports.unsafeGet = exports.unsafeFromArray = exports.union = exports.unfold = exports.toReadonlyArray = exports.takeWhile = exports.takeRight = exports.take = exports.tailNonEmpty = exports.tail = exports.splitWhere = exports.splitAt = exports.split = exports.sort = exports.some = exports.size = exports.separate = exports.reverse = exports.replaceOption = exports.replace = exports.remove = exports.reduceWithIndex = exports.reduceRightWithIndex = exports.reduceRight = exports.reduce = exports.range = exports.prependAllNonEmpty = exports.prepend = exports.partitionWithIndex = exports.partitionMap = exports.partition = exports.of = exports.modifyOption = exports.modify = exports.mapWithIndex = exports.mapAccum = exports.map = exports.makeBy = exports.make = exports.last = exports.join = exports.isNonEmpty = exports.isEmpty = exports.isChunk = exports.intersection = exports.headNonEmpty = exports.head = exports.get = exports.fromIterable = exports.forEach = exports.flatten = exports.flatMap = exports.findLastIndex = exports.findLast = exports.findFirstIndex = exports.findFirst = exports.filterMapWithIndex = exports.filterMapWhile = exports.filterMap = exports.filter = exports.every = exports.empty = exports.elem = exports.dropWhile = exports.dropRight = exports.drop = exports.dedupeAdjacent = exports.dedupe = exports.crossWith = exports.cross = exports.correspondsTo = exports.concat = exports.compact = exports.chunksOf = exports.append = void 0;
var Equal = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/data/Equal"));
var Dual = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/data/Function"));
var Hash = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/data/Hash"));
var O = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/data/Option"));
var RA = /*#__PURE__*/_interopRequireWildcard( /*#__PURE__*/require("@effect/data/ReadonlyArray"));
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
const TypeId = /*#__PURE__*/Symbol.for("@effect/data/Chunk");
/** @internal */
const emptyArray = [];
/** @internal */
function copy(src, srcPos, dest, destPos, len) {
  for (let i = srcPos; i < Math.min(src.length, srcPos + len); i++) {
    dest[destPos + i - srcPos] = src[i];
  }
  return dest;
}
/** @internal */
class ChunkImpl {
  constructor(backing) {
    this.backing = backing;
    this._id = TypeId;
    switch (backing._tag) {
      case "IEmpty":
        {
          this.length = 0;
          this.depth = 0;
          this.left = this;
          this.right = this;
          break;
        }
      case "IConcat":
        {
          this.length = backing.left.length + backing.right.length;
          this.depth = 1 + Math.max(backing.left.depth, backing.right.depth);
          this.left = backing.left;
          this.right = backing.right;
          break;
        }
      case "IArray":
        {
          this.length = backing.array.length;
          this.depth = 0;
          this.left = _empty;
          this.right = _empty;
          break;
        }
      case "ISingleton":
        {
          this.length = 1;
          this.depth = 0;
          this.left = _empty;
          this.right = _empty;
          break;
        }
    }
  }
  toString() {
    return `Chunk(${toReadonlyArray(this).map(String).join(", ")})`;
  }
  toJSON() {
    return {
      _tag: "Chunk",
      values: toReadonlyArray(this)
    };
  }
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return this.toJSON();
  }
  [Equal.symbol](that) {
    if (isChunk(that) && this.length === that.length) {
      return toReadonlyArray(this).every((value, i) => Equal.equals(value, unsafeGet(that, i)));
    }
    return false;
  }
  [Hash.symbol]() {
    return Hash.array(toReadonlyArray(this));
  }
  [Symbol.iterator]() {
    switch (this.backing._tag) {
      case "IArray":
        {
          return this.backing.array[Symbol.iterator]();
        }
      case "IEmpty":
        {
          return emptyArray[Symbol.iterator]();
        }
      default:
        {
          return toReadonlyArray(this)[Symbol.iterator]();
        }
    }
  }
}
/** @internal */
const copyToArray = (self, array, initial) => {
  switch (self.backing._tag) {
    case "IArray":
      {
        copy(self.backing.array, 0, array, initial, self.length);
        break;
      }
    case "IConcat":
      {
        copyToArray(self.left, array, initial);
        copyToArray(self.right, array, initial + self.left.length);
        break;
      }
    case "ISingleton":
      {
        array[initial] = self.backing.a;
        break;
      }
  }
};
/**
 * Checks if `u` is a `Chunk<unknown>`
 *
 * @since 1.0.0
 * @category constructors
 */
const isChunk = u => typeof u === "object" && u != null && "_id" in u && u["_id"] === TypeId;
exports.isChunk = isChunk;
const _empty = /*#__PURE__*/new ChunkImpl({
  _tag: "IEmpty"
});
/**
 * @since 1.0.0
 * @category constructors
 */
const empty = () => _empty;
/**
 * Converts from an `Iterable<A>`
 *
 * @since 1.0.0
 * @category conversions
 */
exports.empty = empty;
const fromIterable = self => isChunk(self) ? self : new ChunkImpl({
  _tag: "IArray",
  array: Array.from(self)
});
/**
 * Converts to a `ReadonlyArray<A>`
 *
 * @since 1.0.0
 * @category conversions
 */
exports.fromIterable = fromIterable;
const toReadonlyArray = self => {
  switch (self.backing._tag) {
    case "IEmpty":
      {
        return emptyArray;
      }
    case "IArray":
      {
        return self.backing.array;
      }
    default:
      {
        const arr = new Array(self.length);
        copyToArray(self, arr, 0);
        self.backing = {
          _tag: "IArray",
          array: arr
        };
        self.left = _empty;
        self.right = _empty;
        self.depth = 0;
        return arr;
      }
  }
};
/**
 * This function provides a safe way to read a value at a particular index from a `Chunk`.
 *
 * @since 1.0.0
 * @category elements
 */
exports.toReadonlyArray = toReadonlyArray;
const get = /*#__PURE__*/Dual.dual(2, (self, index) => index < 0 || index >= self.length ? O.none() : O.some(unsafeGet(self, index)));
/**
 * Wraps an array into a chunk without copying, unsafe on mutable arrays
 *
 * @since 1.0.0
 * @category unsafe
 */
exports.get = get;
const unsafeFromArray = self => new ChunkImpl({
  _tag: "IArray",
  array: self
});
/**
 * Gets an element unsafely, will throw on out of bounds
 *
 * @since 1.0.0
 * @category unsafe
 */
exports.unsafeFromArray = unsafeFromArray;
const unsafeGet = /*#__PURE__*/Dual.dual(2, (self, index) => {
  switch (self.backing._tag) {
    case "IEmpty":
      {
        throw new Error(`Index out of bounds`);
      }
    case "ISingleton":
      {
        if (index !== 0) {
          throw new Error(`Index out of bounds`);
        }
        return self.backing.a;
      }
    case "IArray":
      {
        if (index >= self.length || index < 0) {
          throw new Error(`Index out of bounds`);
        }
        return self.backing.array[index];
      }
    case "IConcat":
      {
        return index < self.left.length ? unsafeGet(self.left, index) : unsafeGet(self.right, index - self.left.length);
      }
  }
});
/**
 * Appends the value to the chunk
 *
 * @since 1.0.0
 * @category mutations
 */
exports.unsafeGet = unsafeGet;
const append = /*#__PURE__*/Dual.dual(2, (self, a) => concat(self, of(a)));
/**
 * Prepends the value to the chunk
 *
 * @since 1.0.0
 * @category mutations
 */
exports.append = append;
const prepend = /*#__PURE__*/Dual.dual(2, (self, a) => concat(of(a), self));
/**
 * Takes the first up to `n` elements from the chunk
 *
 * @since 1.0.0
 * @category mutations
 */
exports.prepend = prepend;
const take = /*#__PURE__*/Dual.dual(2, (self, n) => {
  if (n <= 0) {
    return _empty;
  } else if (n >= self.length) {
    return self;
  } else {
    return unsafeFromArray(RA.take(n)(toReadonlyArray(self)));
  }
});
/**
 * Drops the first up to `n` elements from the chunk
 *
 * @since 1.0.0
 * @category mutations
 */
exports.take = take;
const drop = /*#__PURE__*/Dual.dual(2, (self, n) => {
  if (n <= 0) {
    return self;
  } else if (n >= self.length) {
    return _empty;
  } else {
    return unsafeFromArray(RA.drop(n)(toReadonlyArray(self)));
  }
});
/**
 * Drops the last `n` elements.
 *
 * @since 1.0.0
 * @category mutations
 */
exports.drop = drop;
const dropRight = /*#__PURE__*/Dual.dual(2, (self, n) => take(self, Math.max(0, self.length - n)));
/**
 * Drops all elements so long as the predicate returns true.
 *
 * @since 1.0.0
 * @category mutations
 */
exports.dropRight = dropRight;
const dropWhile = /*#__PURE__*/Dual.dual(2, (self, f) => {
  const arr = toReadonlyArray(self);
  const len = arr.length;
  let i = 0;
  while (i < len && f(arr[i])) {
    i++;
  }
  return drop(i)(self);
});
/**
 * @category mutations
 * @since 1.0.0
 */
exports.dropWhile = dropWhile;
const prependAllNonEmpty = /*#__PURE__*/Dual.dual(2, (self, that) => concat(that, self));
/**
 * Concatenates the two chunks
 *
 * @since 1.0.0
 * @category mutations
 */
exports.prependAllNonEmpty = prependAllNonEmpty;
const concat = /*#__PURE__*/Dual.dual(2, (self, that) => {
  if (self.backing._tag === "IEmpty") {
    return that;
  }
  if (that.backing._tag === "IEmpty") {
    return self;
  }
  const diff = that.depth - self.depth;
  if (Math.abs(diff) <= 1) {
    return new ChunkImpl({
      _tag: "IConcat",
      left: self,
      right: that
    });
  } else if (diff < -1) {
    if (self.left.depth >= self.right.depth) {
      const nr = concat(that)(self.right);
      return new ChunkImpl({
        _tag: "IConcat",
        left: self.left,
        right: nr
      });
    } else {
      const nrr = concat(that)(self.right.right);
      if (nrr.depth === self.depth - 3) {
        const nr = new ChunkImpl({
          _tag: "IConcat",
          left: self.right.left,
          right: nrr
        });
        return new ChunkImpl({
          _tag: "IConcat",
          left: self.left,
          right: nr
        });
      } else {
        const nl = new ChunkImpl({
          _tag: "IConcat",
          left: self.left,
          right: self.right.left
        });
        return new ChunkImpl({
          _tag: "IConcat",
          left: nl,
          right: nrr
        });
      }
    }
  } else {
    if (that.right.depth >= that.left.depth) {
      const nl = concat(that.left)(self);
      return new ChunkImpl({
        _tag: "IConcat",
        left: nl,
        right: that.right
      });
    } else {
      const nll = concat(that.left.left)(self);
      if (nll.depth === that.depth - 3) {
        const nl = new ChunkImpl({
          _tag: "IConcat",
          left: nll,
          right: that.left.right
        });
        return new ChunkImpl({
          _tag: "IConcat",
          left: nl,
          right: that.right
        });
      } else {
        const nr = new ChunkImpl({
          _tag: "IConcat",
          left: that.left.right,
          right: that.right
        });
        return new ChunkImpl({
          _tag: "IConcat",
          left: nll,
          right: nr
        });
      }
    }
  }
});
/**
 * Compares the two chunks of equal length using the specified function
 *
 * @since 1.0.0
 * @category elements
 */
exports.concat = concat;
const correspondsTo = /*#__PURE__*/Dual.dual(3, (self, that, f) => {
  if (self.length !== that.length) {
    return false;
  }
  const selfArray = toReadonlyArray(self);
  const thatArray = toReadonlyArray(that);
  return selfArray.every((v, i) => f(v, thatArray[i]));
});
/**
 * Returns a filtered and mapped subset of the elements.
 *
 * @since 1.0.0
 * @category filtering
 */
exports.correspondsTo = correspondsTo;
const filterMap = /*#__PURE__*/Dual.dual(2, (self, f) => unsafeFromArray(RA.filterMap(f)(self)));
/**
 * Returns a filtered and mapped subset of the elements.
 *
 * @since 1.0.0
 * @category filtering
 */
exports.filterMap = filterMap;
const filter = /*#__PURE__*/Dual.dual(2, (self, predicate) => unsafeFromArray(RA.filterMap(O.liftPredicate(predicate))(self)));
/**
 * Returns a filtered and mapped subset of the elements.
 *
 * @since 1.0.0
 * @category filtering
 */
exports.filter = filter;
const filterMapWithIndex = /*#__PURE__*/Dual.dual(2, (self, f) => unsafeFromArray(RA.filterMap(f)(self)));
/**
 * Transforms all elements of the chunk for as long as the specified function returns some value
 *
 * @since 1.0.0
 * @category filtering
 */
exports.filterMapWithIndex = filterMapWithIndex;
const filterMapWhile = /*#__PURE__*/Dual.dual(2, (self, f) => {
  const res = [];
  for (const a of self) {
    const b = f(a);
    if (O.isSome(b)) {
      res.push(b.value);
    } else {
      break;
    }
  }
  return unsafeFromArray(res);
});
/**
 * Tests whether a value is a member of a `Chunk<A>`.
 *
 * @since 1.0.0
 * @category elements
 */
exports.filterMapWhile = filterMapWhile;
const elem = /*#__PURE__*/Dual.dual(2, (self, b) => RA.contains(Equal.equivalence())(b)(toReadonlyArray(self)));
/**
 * Filter out optional values
 *
 * @since 1.0.0
 * @category filtering
 */
exports.elem = elem;
const compact = self => filterMap(self, Dual.identity);
/**
 * Deduplicates adjacent elements that are identical.
 *
 * @since 1.0.0
 * @category filtering
 */
exports.compact = compact;
const dedupeAdjacent = self => {
  const builder = [];
  let lastA = O.none();
  for (const a of self) {
    if (O.isNone(lastA) || !Equal.equals(a, lastA.value)) {
      builder.push(a);
      lastA = O.some(a);
    }
  }
  return unsafeFromArray(builder);
};
/**
 * Check if a predicate holds true for any `Chunk` member.
 *
 * @since 1.0.0
 * @category elements
 */
exports.dedupeAdjacent = dedupeAdjacent;
const some = /*#__PURE__*/Dual.dual(2, (self, f) => toReadonlyArray(self).findIndex(v => f(v)) !== -1);
/**
 * Check if a predicate holds true for every `Chunk` member.
 *
 * @since 1.0.0
 * @category elements
 */
exports.some = some;
const every = /*#__PURE__*/Dual.dual(2, (self, f) => toReadonlyArray(self).every(v => f(v)));
/**
 * Find the first element which satisfies a predicate (or a refinement) function.
 *
 * @since 1.0.0
 * @category elements
 */
exports.every = every;
const findFirst = /*#__PURE__*/Dual.dual(2, (self, predicate) => RA.findFirst(predicate)(toReadonlyArray(self)));
/**
 * Find the first index for which a predicate holds
 *
 * @since 1.0.0
 * @category elements
 */
exports.findFirst = findFirst;
const findFirstIndex = /*#__PURE__*/Dual.dual(2, (self, f) => RA.findFirstIndex(f)(toReadonlyArray(self)));
/**
 * Find the first index for which a predicate holds
 *
 * @since 1.0.0
 * @category elements
 */
exports.findFirstIndex = findFirstIndex;
const findLastIndex = /*#__PURE__*/Dual.dual(2, (self, f) => RA.findLastIndex(f)(toReadonlyArray(self)));
/**
 * Find the last element which satisfies a predicate function
 *
 * @since 1.0.0
 * @category elements
 */
exports.findLastIndex = findLastIndex;
const findLast = /*#__PURE__*/Dual.dual(2, (self, f) => RA.findLast(f)(toReadonlyArray(self)));
/**
 * Returns a chunk with the elements mapped by the specified function.
 *
 * @since 1.0.0
 * @category sequencing
 */
exports.findLast = findLast;
const flatMap = /*#__PURE__*/Dual.dual(2, (self, f) => {
  if (self.backing._tag === "ISingleton") {
    return f(self.backing.a);
  }
  let r = _empty;
  for (const k of self) {
    r = concat(f(k))(r);
  }
  return r;
});
/**
 * Flattens a chunk of chunks into a single chunk by concatenating all chunks.
 *
 * @since 1.0.0
 * @category sequencing
 */
exports.flatMap = flatMap;
const flatten = /*#__PURE__*/flatMap(Dual.identity);
/**
 * Iterate over the chunk applying `f`.
 *
 * @since 1.0.0
 * @category elements
 */
exports.flatten = flatten;
const forEach = /*#__PURE__*/Dual.dual(2, (self, f) => self.backing._tag === "ISingleton" ? f(self.backing.a) : toReadonlyArray(self).forEach(f));
/**
 * Groups elements in chunks of up to `n` elements.
 *
 * @since 1.0.0
 * @category elements
 */
exports.forEach = forEach;
const chunksOf = /*#__PURE__*/Dual.dual(2, (self, n) => {
  const gr = [];
  let current = [];
  toReadonlyArray(self).forEach(a => {
    current.push(a);
    if (current.length >= n) {
      gr.push(unsafeFromArray(current));
      current = [];
    }
  });
  if (current.length > 0) {
    gr.push(unsafeFromArray(current));
  }
  return unsafeFromArray(gr);
});
/**
 * Returns the first element of this chunk if it exists.
 *
 * @since 1.0.0
 * @category elements
 */
exports.chunksOf = chunksOf;
const head = /*#__PURE__*/get(0);
/**
 * Creates a Chunk of unique values that are included in all given Chunks.
 *
 * The order and references of result values are determined by the Chunk.
 *
 * @since 1.0.0
 * @category elements
 */
exports.head = head;
const intersection = /*#__PURE__*/Dual.dual(2, (self, that) => unsafeFromArray(RA.intersection(Equal.equivalence())(toReadonlyArray(that))(toReadonlyArray(self))));
/**
 * Determines if the chunk is empty.
 *
 * @since 1.0.0
 * @category elements
 */
exports.intersection = intersection;
const isEmpty = self => self.length === 0;
/**
 * Determines if the chunk is not empty.
 *
 * @since 1.0.0
 * @category elements
 */
exports.isEmpty = isEmpty;
const isNonEmpty = self => self.length > 0;
/**
 * Folds over the elements in this chunk from the left.
 *
 * @since 1.0.0
 * @category folding
 */
exports.isNonEmpty = isNonEmpty;
const reduce = /*#__PURE__*/Dual.dual(3, (self, b, f) => RA.reduce(b, f)(toReadonlyArray(self)));
/**
 * Folds over the elements in this chunk from the left.
 *
 * @since 1.0.0
 * @category folding
 */
exports.reduce = reduce;
const reduceWithIndex = /*#__PURE__*/Dual.dual(3, (self, b, f) => RA.reduce(b, f)(toReadonlyArray(self)));
/**
 * Folds over the elements in this chunk from the right.
 *
 * @since 1.0.0
 * @category folding
 */
exports.reduceWithIndex = reduceWithIndex;
const reduceRight = /*#__PURE__*/Dual.dual(3, (self, b, f) => RA.reduceRight(b, (b, a) => f(b, a))(toReadonlyArray(self)));
/**
 * Folds over the elements in this chunk from the right.
 *
 * @since 1.0.0
 * @category folding
 */
exports.reduceRight = reduceRight;
const reduceRightWithIndex = /*#__PURE__*/Dual.dual(3, (self, b, f) => RA.reduceRight(b, f)(toReadonlyArray(self)));
/**
 * Joins the elements together with "sep" in the middle.
 *
 * @since 1.0.0
 * @category folding
 */
exports.reduceRightWithIndex = reduceRightWithIndex;
const join = /*#__PURE__*/Dual.dual(2, (self, sep) => reduce(self, "", (s, a) => s.length > 0 ? `${s}${sep}${a}` : a));
/**
 * Returns the last element of this chunk if it exists.
 *
 * @since 1.0.0
 * @category elements
 */
exports.join = join;
const last = self => get(self, self.length - 1);
/**
 * Builds a `NonEmptyChunk` from an non-empty collection of elements.
 *
 * @since 1.0.0
 * @category constructors
 */
exports.last = last;
const make = (...as) => unsafeFromArray(as);
/**
 * Builds a `NonEmptyChunk` from a single element.
 *
 * @since 1.0.0
 * @category constructors
 */
exports.make = make;
const of = a => new ChunkImpl({
  _tag: "ISingleton",
  a
});
/**
 * Return a Chunk of length n with element i initialized with f(i).
 *
 * **Note**. `n` is normalized to an integer >= 1.
 *
 * @since 1.0.0
 * @category constructors
 */
exports.of = of;
const makeBy = /*#__PURE__*/Dual.dual(2, (n, f) => make(...RA.makeBy(n, f)));
/**
 * Returns an effect whose success is mapped by the specified f function.
 *
 * @since 1.0.0
 * @category mapping
 */
exports.makeBy = makeBy;
const map = /*#__PURE__*/Dual.dual(2, (self, f) => self.backing._tag === "ISingleton" ? of(f(self.backing.a)) : unsafeFromArray(RA.map(f)(toReadonlyArray(self))));
/**
 * Returns an effect whose success is mapped by the specified f function.
 *
 * @since 1.0.0
 * @category mapping
 */
exports.map = map;
const mapWithIndex = /*#__PURE__*/Dual.dual(2, (self, f) => self.backing._tag === "ISingleton" ? of(f(self.backing.a, 0)) : unsafeFromArray(RA.map(f)(toReadonlyArray(self))));
/**
 * Statefully maps over the chunk, producing new elements of type `B`.
 *
 * @since 1.0.0
 * @category folding
 */
exports.mapWithIndex = mapWithIndex;
const mapAccum = /*#__PURE__*/Dual.dual(3, (self, s, f) => {
  let s1 = s;
  const res = [];
  for (const a of toReadonlyArray(self)) {
    const r = f(s1, a);
    s1 = r[0];
    res.push(r[1]);
  }
  return [s1, unsafeFromArray(res)];
});
/**
 * Separate elements based on a predicate that also exposes the index of the element.
 *
 * @category filtering
 * @since 1.0.0
 */
exports.mapAccum = mapAccum;
const partitionWithIndex = /*#__PURE__*/Dual.dual(2, (self, f) => (([l, r]) => [unsafeFromArray(l), unsafeFromArray(r)])(RA.partition(f)(toReadonlyArray(self))));
/**
 * Separate elements based on a predicate.
 *
 * @category filtering
 * @since 1.0.0
 */
exports.partitionWithIndex = partitionWithIndex;
const partition = /*#__PURE__*/Dual.dual(2, (self, predicate) => (([l, r]) => [unsafeFromArray(l), unsafeFromArray(r)])(RA.partition(predicate)(toReadonlyArray(self))));
/**
 * Partitions the elements of this chunk into two chunks using f.
 *
 * @category filtering
 * @since 1.0.0
 */
exports.partition = partition;
const partitionMap = /*#__PURE__*/Dual.dual(2, (self, f) => (([l, r]) => [unsafeFromArray(l), unsafeFromArray(r)])(RA.partitionMap(f)(toReadonlyArray(self))));
/**
 * Partitions the elements of this chunk into two chunks.
 *
 * @category filtering
 * @since 1.0.0
 */
exports.partitionMap = partitionMap;
const separate = self => (([l, r]) => [unsafeFromArray(l), unsafeFromArray(r)])(RA.separate(toReadonlyArray(self)));
/**
 * Create a non empty `Chunk` containing a range of integers, including both endpoints.
 *
 * @category constructors
 * @since 1.0.0
 */
exports.separate = separate;
const range = (start, end) => start <= end ? makeBy(end - start + 1, i => start + i) : of(start);
/**
 * Reverse a Chunk, creating a new Chunk.
 *
 * @since 1.0.0
 * @category elements
 */
exports.range = range;
const reverse = self => unsafeFromArray(RA.reverse(toReadonlyArray(self)));
/**
 * Retireves the size of the chunk
 *
 * @since 1.0.0
 * @category elements
 */
exports.reverse = reverse;
const size = self => self.length;
/**
 * Sort the elements of a Chunk in increasing order, creating a new Chunk.
 *
 * @since 1.0.0
 * @category elements
 */
exports.size = size;
const sort = /*#__PURE__*/Dual.dual(2, (self, O) => unsafeFromArray(RA.sort(O)(toReadonlyArray(self))));
/**
 *  Returns two splits of this chunk at the specified index.
 *
 * @since 1.0.0
 * @category elements
 */
exports.sort = sort;
const splitAt = /*#__PURE__*/Dual.dual(2, (self, n) => [take(n)(self), drop(n)(self)]);
/**
 * Splits this chunk into `n` equally sized chunks.
 *
 * @since 1.0.0
 * @category elements
 */
exports.splitAt = splitAt;
const split = /*#__PURE__*/Dual.dual(2, (self, n) => {
  const length = self.length;
  const k = Math.floor(n);
  const quotient = Math.floor(length / k);
  const remainder = length % k;
  const chunks = [];
  let i = 0;
  let chunk = [];
  toReadonlyArray(self).forEach(a => {
    chunk.push(a);
    if (i <= remainder && chunk.length > quotient || i > remainder && chunk.length >= quotient) {
      chunks.push(unsafeFromArray(chunk));
      chunk = [];
    }
    i++;
  });
  if (chunk.length > 0) {
    chunks.push(unsafeFromArray(chunk));
  }
  return unsafeFromArray(chunks);
});
/**
 * Splits this chunk on the first element that matches this predicate.
 *
 * @since 1.0.0
 * @category elements
 */
exports.split = split;
const splitWhere = /*#__PURE__*/Dual.dual(2, (self, f) => {
  let i = 0;
  for (const a of toReadonlyArray(self)) {
    if (f(a)) {
      break;
    } else {
      i++;
    }
  }
  return splitAt(i)(self);
});
/**
 * Returns every elements after the first.
 *
 * @since 1.0.0
 * @category elements
 */
exports.splitWhere = splitWhere;
const tail = self => self.length > 0 ? O.some(drop(1)(self)) : O.none();
/**
 * Takes the last `n` elements.
 *
 * @since 1.0.0
 * @category elements
 */
exports.tail = tail;
const takeRight = /*#__PURE__*/Dual.dual(2, (self, n) => drop(self, self.length - n));
/**
 * Takes all elements so long as the predicate returns true.
 *
 * @since 1.0.0
 * @category elements
 */
exports.takeRight = takeRight;
const takeWhile = /*#__PURE__*/Dual.dual(2, (self, f) => {
  const res = [];
  for (const a of toReadonlyArray(self)) {
    if (f(a)) {
      res.push(a);
    } else {
      break;
    }
  }
  return unsafeFromArray(res);
});
/**
 * Constructs a `Chunk` by repeatedly applying the function `f` as long as it * returns `Some`.
 *
 * @since 1.0.0
 * @category elements
 */
exports.takeWhile = takeWhile;
const unfold = (s, f) => {
  const builder = [];
  let cont = true;
  let s1 = s;
  while (cont) {
    const x = f(s1);
    if (O.isSome(x)) {
      s1 = x.value[1];
      builder.push(x.value[0]);
    } else {
      cont = false;
    }
  }
  return unsafeFromArray(builder);
};
/**
 * Creates a Chunks of unique values, in order, from all given Chunks.
 *
 * @since 1.0.0
 * @category elements
 */
exports.unfold = unfold;
const union = /*#__PURE__*/Dual.dual(2, (self, that) => unsafeFromArray(RA.union(Equal.equivalence())(toReadonlyArray(that))(toReadonlyArray(self))));
/**
 * Remove duplicates from an array, keeping the first occurrence of an element.
 *
 * @since 1.0.0
 * @category elements
 */
exports.union = union;
const dedupe = self => unsafeFromArray(RA.uniq(Equal.equivalence())(toReadonlyArray(self)));
/**
 * Returns the first element of this chunk.
 *
 * @since 1.0.0
 * @category unsafe
 */
exports.dedupe = dedupe;
const unsafeHead = self => unsafeGet(0)(self);
/**
 * Returns the last element of this chunk.
 *
 * @since 1.0.0
 * @category unsafe
 */
exports.unsafeHead = unsafeHead;
const unsafeLast = self => unsafeGet(self.length - 1)(self);
/**
 * Takes an array of pairs and return two corresponding arrays.
 *
 * Note: The function is reverse of `zip`.
 *
 * @since 1.0.0
 * @category elements
 */
exports.unsafeLast = unsafeLast;
const unzip = as => {
  const fa = [];
  const fb = [];
  toReadonlyArray(as).forEach(([a, b]) => {
    fa.push(a);
    fb.push(b);
  });
  return [unsafeFromArray(fa), unsafeFromArray(fb)];
};
/**
 * Zips this chunk pointwise with the specified chunk.
 *
 * @since 1.0.0
 * @category elements
 */
exports.unzip = unzip;
const zip = /*#__PURE__*/Dual.dual(2, (self, that) => zipWith(self, that, (a, b) => [a, b]));
/**
 * Zips this chunk pointwise with the specified chunk using the specified combiner.
 *
 * @since 1.0.0
 * @category elements
 */
exports.zip = zip;
const zipWith = /*#__PURE__*/Dual.dual(3, (self, that, f) => {
  const selfA = toReadonlyArray(self);
  const thatA = toReadonlyArray(that);
  return unsafeFromArray(RA.zipWith(thatA, f)(selfA));
});
/**
 * Zips this chunk pointwise with the specified chunk to produce a new chunk with
 * pairs of elements from each chunk, filling in missing values from the
 * shorter chunk with `None`. The returned chunk will have the length of the
 * longer chunk.
 *
 * @since 1.0.0
 * @category elements
 */
exports.zipWith = zipWith;
const zipAll = /*#__PURE__*/Dual.dual(2, (self, that) => zipAllWith(self, that, (a, b) => [O.some(a), O.some(b)], a => [O.some(a), O.none()], b => [O.none(), O.some(b)]));
/**
 * Zips with chunk with the specified chunk to produce a new chunk with
 * pairs of elements from each chunk combined using the specified function
 * `both`. If one chunk is shorter than the other uses the specified
 * function `left` or `right` to map the element that does exist to the
 * result type.
 *
 * @since 1.0.0
 * @category elements
 */
exports.zipAll = zipAll;
const zipAllWith = /*#__PURE__*/Dual.dual(5, (self, that, f, left, right) => {
  const length = Math.max(self.length, that.length);
  if (length === 0) {
    return _empty;
  }
  const leftarr = toReadonlyArray(self);
  const rightArr = toReadonlyArray(that);
  let i = 0;
  let j = 0;
  let k = 0;
  const leftLength = leftarr.length;
  const rightLength = rightArr.length;
  const builder = new Array(length);
  while (i < length) {
    if (j < leftLength && k < rightLength) {
      builder[i] = f(leftarr[j], rightArr[k]);
      i++;
      j++;
      k++;
    } else if (j < leftLength) {
      builder[i] = left(leftarr[j]);
      i++;
      j++;
    } else if (k < rightLength) {
      builder[i] = right(rightArr[k]);
      i++;
      k++;
    }
  }
  return unsafeFromArray(builder);
});
/**
 * Zips this chunk crosswise with the specified chunk using the specified combiner.
 *
 * @since 1.0.0
 * @category elements
 */
exports.zipAllWith = zipAllWith;
const crossWith = /*#__PURE__*/Dual.dual(3, (self, that, f) => flatMap(self, a => map(b => f(a, b))(that)));
/**
 * Zips this chunk crosswise with the specified chunk.
 *
 * @since 1.0.0
 * @category elements
 */
exports.crossWith = crossWith;
const cross = /*#__PURE__*/Dual.dual(2, (self, that) => crossWith(self, that, (a, b) => [a, b]));
/**
 * Zips this chunk with the index of every element, starting from the initial
 * index value.
 *
 * @category elements
 * @since 1.0.0
 */
exports.cross = cross;
const zipWithIndex = self => zipWithIndexOffset(0)(self);
/**
 * Zips this chunk with the index of every element, starting from the initial
 * index value.
 *
 * @category elements
 * @since 1.0.0
 */
exports.zipWithIndex = zipWithIndex;
const zipWithIndexOffset = /*#__PURE__*/Dual.dual(2, (self, offset) => {
  const iterator = self[Symbol.iterator]();
  let next;
  let i = offset;
  const builder = [];
  while (!(next = iterator.next()).done) {
    builder.push([next.value, i]);
    i = i + 1;
  }
  return unsafeFromArray(builder);
});
/**
 * Delete the element at the specified index, creating a new `Chunk`,
 * or returning the input if the index is out of bounds.
 *
 * @category mutations
 * @since 1.0.0
 */
exports.zipWithIndexOffset = zipWithIndexOffset;
const remove = /*#__PURE__*/Dual.dual(2, (self, i) => unsafeFromArray(RA.remove(i)(toReadonlyArray(self))));
/**
 * Change the element at the specified index, creating a new `Chunk`,
 * or returning the input if the index is out of bounds.
 *
 * @category mutations
 * @since 1.0.0
 */
exports.remove = remove;
const replace = /*#__PURE__*/Dual.dual(3, (self, i, b) => modify(self, i, () => b));
/**
 * @category mutations
 * @since 1.0.0
 */
exports.replace = replace;
const replaceOption = /*#__PURE__*/Dual.dual(3, (self, i, b) => modifyOption(self, i, () => b));
/**
 * Apply a function to the element at the specified index, creating a new `Chunk`,
 * or returning the input if the index is out of bounds.
 *
 * @category mutations
 * @since 1.0.0
 */
exports.replaceOption = replaceOption;
const modify = /*#__PURE__*/Dual.dual(3, (self, i, f) => O.getOrElse(() => self)(modifyOption(self, i, f)));
/**
 * @category mutations
 * @since 1.0.0
 */
exports.modify = modify;
const modifyOption = /*#__PURE__*/Dual.dual(3, (self, i, f) => O.map(unsafeFromArray)(RA.modifyOption(i, f)(toReadonlyArray(self))));
/**
 * Returns the first element of this non empty chunk.
 *
 * @since 1.0.0
 * @category elements
 */
exports.modifyOption = modifyOption;
const headNonEmpty = unsafeHead;
/**
 * Returns every elements after the first.
 *
 * @since 1.0.0
 * @category elements
 */
exports.headNonEmpty = headNonEmpty;
const tailNonEmpty = self => drop(self, 1);
exports.tailNonEmpty = tailNonEmpty;
//# sourceMappingURL=Chunk.js.map