import{Buffer as e}from"buffer";import{noChange as r,_$LH as t}from"./lit-html.js";import{PartType as n}from"./directive.js";import{isPrimitive as o,isTemplateResult as l,isSingleExpression as i}from"./directive-helpers.js";const{R:a,D:s,V:c,I:d,F:f}=t,p=(e,r,t={})=>{if(void 0!==r._$litPart$)throw Error("container already contains a live render");let n,o;const l=[],i=document.createTreeWalker(r,NodeFilter.SHOW_COMMENT,null,!1);let a;for(;null!==(a=i.nextNode());){const r=a.data;if(r.startsWith("lit-part")){if(0===l.length&&void 0!==n)throw Error("there must be only one root part per container");o=u(e,a,l,t),null!=n||(n=o)}else if(r.startsWith("lit-node"))h(a,l,t);else if(r.startsWith("/lit-part")){if(1===l.length&&o!==n)throw Error("internal error");o=m(a,o,l)}}console.assert(void 0!==n,"there should be exactly one root part in a render container"),r._$litPart$=n},u=(e,t,n,i)=>{let f,p;if(0===n.length)p=new d(t,null,void 0,i),f=e;else{const e=n[n.length-1];if("template-instance"===e.type)p=new d(t,null,e.instance,i),e.instance.u.push(p),f=e.result.values[e.instancePartIndex++],e.templatePartIndex++;else if("iterable"===e.type){p=new d(t,null,e.part,i);const r=e.iterator.next();if(r.done)throw f=void 0,e.done=!0,Error("Unhandled shorter than expected iterable");f=r.value,e.part._$AH.push(p)}else p=new d(t,null,e.part,i)}if(f=c(p,f),f===r)n.push({part:p,type:"leaf"});else if(o(f))n.push({part:p,type:"leaf"}),p._$AH=f;else if(l(f)){const e="lit-part "+w(f);if(t.data!==e)throw Error("Hydration value mismatch: Unexpected TemplateResult rendered to part");{const e=d.prototype._$AC(f),r=new a(e,p);n.push({type:"template-instance",instance:r,part:p,templatePartIndex:0,instancePartIndex:0,result:f}),p._$AH=r}}else s(f)?(n.push({part:p,type:"iterable",value:f,iterator:f[Symbol.iterator](),done:!1}),p._$AH=[]):(n.push({part:p,type:"leaf"}),p._$AH=null==f?"":f);return p},m=(e,r,t)=>{if(void 0===r)throw Error("unbalanced part marker");r._$AB=e;const n=t.pop();if("iterable"===n.type&&!n.iterator.next().done)throw Error("unexpected longer than expected iterable");if(t.length>0)return t[t.length-1].part},h=(e,r,t)=>{var o;const l=/lit-node (\d+)/.exec(e.data),a=parseInt(l[1]),s=null!==(o=e.previousElementSibling)&&void 0!==o?o:e.parentElement;if(null===s)throw Error("could not find node for attribute parts");s.removeAttribute("defer-hydration");const d=r[r.length-1];if("template-instance"!==d.type)throw Error("internal error");{const e=d.instance;for(;;){const r=e._$AD.parts[d.templatePartIndex];if(void 0===r||r.type!==n.ATTRIBUTE&&r.type!==n.ELEMENT||r.index!==a)break;if(r.type===n.ATTRIBUTE){const o=new r.ctor(s,r.name,r.strings,d.instance,t),l=i(o)?d.result.values[d.instancePartIndex]:d.result.values,a=!(o.type===n.EVENT||o.type===n.PROPERTY);o._$AI(l,o,d.instancePartIndex,a),d.instancePartIndex+=r.strings.length-1,e.u.push(o)}else{const r=new f(s,d.instance,t);c(r,d.result.values[d.instancePartIndex++]),e.u.push(r)}d.templatePartIndex++}}},w=r=>{const t=new Uint32Array(2).fill(5381);for(const e of r.strings)for(let r=0;r<e.length;r++)t[r%2]=33*t[r%2]^e.charCodeAt(r);const n=String.fromCharCode(...new Uint8Array(t.buffer));return e.from(n,"binary").toString("base64")};export{w as digestForTemplateResult,p as hydrate};
//# sourceMappingURL=experimental-hydrate.js.map
