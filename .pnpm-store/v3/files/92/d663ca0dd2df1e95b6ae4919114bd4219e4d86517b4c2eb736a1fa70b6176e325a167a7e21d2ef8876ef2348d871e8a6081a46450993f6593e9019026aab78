/**
 * @since 1.0.0
 */
import type { Either } from "@effect/data/Either";
import * as Equal from "@effect/data/Equal";
import type { TypeLambda } from "@effect/data/HKT";
import type { NonEmptyIterable } from "@effect/data/NonEmpty";
import type { Option } from "@effect/data/Option";
import type { Predicate, Refinement } from "@effect/data/Predicate";
import type { Order } from "@effect/data/typeclass/Order";
declare const TypeId: unique symbol;
/**
 * @since 1.0.0
 * @category symbol
 */
export type TypeId = typeof TypeId;
/**
 * @category model
 * @since 1.0.0
 */
export interface NonEmptyChunk<A> extends Chunk<A>, NonEmptyIterable<A> {
}
/**
 * @since 1.0.0
 * @category models
 */
export interface Chunk<A> extends Iterable<A>, Equal.Equal {
    readonly _id: TypeId;
    readonly length: number;
}
/**
 * @since 1.0.0
 * @category type lambdas
 */
export interface ChunkTypeLambda extends TypeLambda {
    readonly type: Chunk<this["Target"]>;
}
/**
 * Checks if `u` is a `Chunk<unknown>`
 *
 * @since 1.0.0
 * @category constructors
 */
export declare const isChunk: {
    <A>(u: Iterable<A>): u is Chunk<A>;
    (u: unknown): u is Chunk<unknown>;
};
/**
 * @since 1.0.0
 * @category constructors
 */
export declare const empty: <A = never>() => Chunk<A>;
/**
 * Converts from an `Iterable<A>`
 *
 * @since 1.0.0
 * @category conversions
 */
export declare const fromIterable: <A>(self: Iterable<A>) => Chunk<A>;
/**
 * Converts to a `ReadonlyArray<A>`
 *
 * @since 1.0.0
 * @category conversions
 */
export declare const toReadonlyArray: <A>(self: Chunk<A>) => readonly A[];
/**
 * This function provides a safe way to read a value at a particular index from a `Chunk`.
 *
 * @since 1.0.0
 * @category elements
 */
export declare const get: {
    (index: number): <A>(self: Chunk<A>) => Option<A>;
    <A>(self: Chunk<A>, index: number): Option<A>;
};
/**
 * Wraps an array into a chunk without copying, unsafe on mutable arrays
 *
 * @since 1.0.0
 * @category unsafe
 */
export declare const unsafeFromArray: <A>(self: readonly A[]) => Chunk<A>;
/**
 * Gets an element unsafely, will throw on out of bounds
 *
 * @since 1.0.0
 * @category unsafe
 */
export declare const unsafeGet: {
    (index: number): <A>(self: Chunk<A>) => A;
    <A>(self: Chunk<A>, index: number): A;
};
/**
 * Appends the value to the chunk
 *
 * @since 1.0.0
 * @category mutations
 */
export declare const append: {
    <A2>(a: A2): <A>(self: Chunk<A>) => Chunk<A2 | A>;
    <A, A2>(self: Chunk<A>, a: A2): Chunk<A | A2>;
};
/**
 * Prepends the value to the chunk
 *
 * @since 1.0.0
 * @category mutations
 */
export declare const prepend: {
    <B>(elem: B): <A>(self: Chunk<A>) => Chunk<B | A>;
    <A, B>(self: Chunk<A>, elem: B): Chunk<A | B>;
};
/**
 * Takes the first up to `n` elements from the chunk
 *
 * @since 1.0.0
 * @category mutations
 */
export declare const take: {
    (n: number): <A>(self: Chunk<A>) => Chunk<A>;
    <A>(self: Chunk<A>, n: number): Chunk<A>;
};
/**
 * Drops the first up to `n` elements from the chunk
 *
 * @since 1.0.0
 * @category mutations
 */
export declare const drop: {
    (n: number): <A>(self: Chunk<A>) => Chunk<A>;
    <A>(self: Chunk<A>, n: number): Chunk<A>;
};
/**
 * Drops the last `n` elements.
 *
 * @since 1.0.0
 * @category mutations
 */
export declare const dropRight: {
    (n: number): <A>(self: Chunk<A>) => Chunk<A>;
    <A>(self: Chunk<A>, n: number): Chunk<A>;
};
/**
 * Drops all elements so long as the predicate returns true.
 *
 * @since 1.0.0
 * @category mutations
 */
export declare const dropWhile: {
    <A>(f: (a: A) => boolean): (self: Chunk<A>) => Chunk<A>;
    <A>(self: Chunk<A>, f: (a: A) => boolean): Chunk<A>;
};
/**
 * @category mutations
 * @since 1.0.0
 */
export declare const prependAllNonEmpty: {
    <B>(that: NonEmptyChunk<B>): <A>(self: Chunk<A>) => NonEmptyChunk<B | A>;
    <B>(that: Chunk<B>): <A>(self: NonEmptyChunk<A>) => NonEmptyChunk<B | A>;
    <A, B>(self: Chunk<A>, that: NonEmptyChunk<B>): NonEmptyChunk<A | B>;
    <A, B>(self: NonEmptyChunk<A>, that: Chunk<B>): NonEmptyChunk<A | B>;
};
/**
 * Concatenates the two chunks
 *
 * @since 1.0.0
 * @category mutations
 */
export declare const concat: {
    <B>(that: Chunk<B>): <A>(self: Chunk<A>) => Chunk<B | A>;
    <A, B>(self: Chunk<A>, that: Chunk<B>): Chunk<A | B>;
};
/**
 * Compares the two chunks of equal length using the specified function
 *
 * @since 1.0.0
 * @category elements
 */
export declare const correspondsTo: {
    <A, B>(that: Chunk<B>, f: (a: A, b: B) => boolean): (self: Chunk<A>) => boolean;
    <A, B>(self: Chunk<A>, that: Chunk<B>, f: (a: A, b: B) => boolean): boolean;
};
/**
 * Returns a filtered and mapped subset of the elements.
 *
 * @since 1.0.0
 * @category filtering
 */
export declare const filterMap: {
    <A, B>(f: (a: A) => Option<B>): (self: Iterable<A>) => Chunk<B>;
    <A, B>(self: Iterable<A>, f: (a: A) => Option<B>): Chunk<B>;
};
/**
 * Returns a filtered and mapped subset of the elements.
 *
 * @since 1.0.0
 * @category filtering
 */
export declare const filter: {
    <C extends A, B extends A, A = C>(refinement: Refinement<A, B>): (self: Chunk<C>) => Chunk<B>;
    <B extends A, A = B>(predicate: Predicate<A>): (self: Chunk<B>) => Chunk<B>;
    <C extends A, B extends A, A = C>(self: Chunk<C>, refinement: Refinement<A, B>): Chunk<B>;
    <B extends A, A = B>(self: Chunk<B>, predicate: Predicate<A>): Chunk<B>;
};
/**
 * Returns a filtered and mapped subset of the elements.
 *
 * @since 1.0.0
 * @category filtering
 */
export declare const filterMapWithIndex: {
    <A, B>(f: (a: A, i: number) => Option<B>): (self: Iterable<A>) => Chunk<B>;
    <A, B>(self: Iterable<A>, f: (a: A, i: number) => Option<B>): Chunk<B>;
};
/**
 * Transforms all elements of the chunk for as long as the specified function returns some value
 *
 * @since 1.0.0
 * @category filtering
 */
export declare const filterMapWhile: {
    <A, B>(f: (a: A) => Option<B>): (self: Iterable<A>) => Chunk<B>;
    <A, B>(self: Iterable<A>, f: (a: A) => Option<B>): Chunk<B>;
};
/**
 * Tests whether a value is a member of a `Chunk<A>`.
 *
 * @since 1.0.0
 * @category elements
 */
export declare const elem: {
    <B>(b: B): <A>(self: Chunk<A>) => boolean;
    <A, B>(self: Chunk<A>, b: B): boolean;
};
/**
 * Filter out optional values
 *
 * @since 1.0.0
 * @category filtering
 */
export declare const compact: <A>(self: Iterable<Option<A>>) => Chunk<A>;
/**
 * Deduplicates adjacent elements that are identical.
 *
 * @since 1.0.0
 * @category filtering
 */
export declare const dedupeAdjacent: <A>(self: Chunk<A>) => Chunk<A>;
/**
 * Check if a predicate holds true for any `Chunk` member.
 *
 * @since 1.0.0
 * @category elements
 */
export declare const some: {
    <A>(f: Predicate<A>): (self: Chunk<A>) => boolean;
    <A>(self: Chunk<A>, f: Predicate<A>): boolean;
};
/**
 * Check if a predicate holds true for every `Chunk` member.
 *
 * @since 1.0.0
 * @category elements
 */
export declare const every: {
    <A>(f: Predicate<A>): (self: Chunk<A>) => boolean;
    <A>(self: Chunk<A>, f: Predicate<A>): boolean;
};
/**
 * Find the first element which satisfies a predicate (or a refinement) function.
 *
 * @since 1.0.0
 * @category elements
 */
export declare const findFirst: {
    <A, B extends A>(refinement: Refinement<A, B>): (self: Chunk<A>) => Option<B>;
    <A>(predicate: Predicate<A>): (self: Chunk<A>) => Option<A>;
    <A, B extends A>(self: Chunk<A>, refinement: Refinement<A, B>): Option<B>;
    <A>(self: Chunk<A>, predicate: Predicate<A>): Option<A>;
};
/**
 * Find the first index for which a predicate holds
 *
 * @since 1.0.0
 * @category elements
 */
export declare const findFirstIndex: {
    <A>(f: Predicate<A>): (self: Chunk<A>) => Option<number>;
    <A>(self: Chunk<A>, f: Predicate<A>): Option<number>;
};
/**
 * Find the first index for which a predicate holds
 *
 * @since 1.0.0
 * @category elements
 */
export declare const findLastIndex: {
    <A>(f: Predicate<A>): (self: Chunk<A>) => Option<number>;
    <A>(self: Chunk<A>, f: Predicate<A>): Option<number>;
};
/**
 * Find the last element which satisfies a predicate function
 *
 * @since 1.0.0
 * @category elements
 */
export declare const findLast: {
    <A, B extends A>(f: Refinement<A, B>): (self: Chunk<A>) => Option<B>;
    <A>(f: Predicate<A>): (self: Chunk<A>) => Option<A>;
    <A, B extends A>(self: Chunk<A>, f: Refinement<A, B>): Option<B>;
    <A>(self: Chunk<A>, f: Predicate<A>): Option<A>;
};
/**
 * Returns a chunk with the elements mapped by the specified function.
 *
 * @since 1.0.0
 * @category sequencing
 */
export declare const flatMap: {
    <A, B>(f: (a: A) => Chunk<B>): (self: Chunk<A>) => Chunk<B>;
    <A, B>(self: Chunk<A>, f: (a: A) => Chunk<B>): Chunk<B>;
};
/**
 * Flattens a chunk of chunks into a single chunk by concatenating all chunks.
 *
 * @since 1.0.0
 * @category sequencing
 */
export declare const flatten: <A>(self: Chunk<Chunk<A>>) => Chunk<A>;
/**
 * Iterate over the chunk applying `f`.
 *
 * @since 1.0.0
 * @category elements
 */
export declare const forEach: {
    <A>(f: (a: A) => void): (self: Chunk<A>) => void;
    <A>(self: Chunk<A>, f: (a: A) => void): void;
};
/**
 * Groups elements in chunks of up to `n` elements.
 *
 * @since 1.0.0
 * @category elements
 */
export declare const chunksOf: {
    (n: number): <A>(self: Chunk<A>) => Chunk<Chunk<A>>;
    <A>(self: Chunk<A>, n: number): Chunk<Chunk<A>>;
};
/**
 * Returns the first element of this chunk if it exists.
 *
 * @since 1.0.0
 * @category elements
 */
export declare const head: <A>(self: Chunk<A>) => Option<A>;
/**
 * Creates a Chunk of unique values that are included in all given Chunks.
 *
 * The order and references of result values are determined by the Chunk.
 *
 * @since 1.0.0
 * @category elements
 */
export declare const intersection: {
    <A>(that: Chunk<A>): <B>(self: Chunk<B>) => Chunk<A & B>;
    <A, B>(self: Chunk<A>, that: Chunk<B>): Chunk<A & B>;
};
/**
 * Determines if the chunk is empty.
 *
 * @since 1.0.0
 * @category elements
 */
export declare const isEmpty: <A>(self: Chunk<A>) => boolean;
/**
 * Determines if the chunk is not empty.
 *
 * @since 1.0.0
 * @category elements
 */
export declare const isNonEmpty: <A>(self: Chunk<A>) => self is NonEmptyChunk<A>;
/**
 * Folds over the elements in this chunk from the left.
 *
 * @since 1.0.0
 * @category folding
 */
export declare const reduce: {
    <A, B>(b: B, f: (s: B, a: A) => B): (self: Chunk<A>) => B;
    <A, B>(self: Chunk<A>, b: B, f: (s: B, a: A) => B): B;
};
/**
 * Folds over the elements in this chunk from the left.
 *
 * @since 1.0.0
 * @category folding
 */
export declare const reduceWithIndex: {
    <B, A>(b: B, f: (b: B, a: A, i: number) => B): (self: Chunk<A>) => B;
    <A, B>(self: Chunk<A>, b: B, f: (b: B, a: A, i: number) => B): B;
};
/**
 * Folds over the elements in this chunk from the right.
 *
 * @since 1.0.0
 * @category folding
 */
export declare const reduceRight: {
    <B, A>(b: B, f: (b: B, a: A) => B): (self: Chunk<A>) => B;
    <A, B>(self: Chunk<A>, b: B, f: (b: B, a: A) => B): B;
};
/**
 * Folds over the elements in this chunk from the right.
 *
 * @since 1.0.0
 * @category folding
 */
export declare const reduceRightWithIndex: {
    <B, A>(b: B, f: (b: B, a: A, i: number) => B): (self: Chunk<A>) => B;
    <A, B>(self: Chunk<A>, b: B, f: (b: B, a: A, i: number) => B): B;
};
/**
 * Joins the elements together with "sep" in the middle.
 *
 * @since 1.0.0
 * @category folding
 */
export declare const join: {
    (sep: string): (self: Chunk<string>) => string;
    (self: Chunk<string>, sep: string): string;
};
/**
 * Returns the last element of this chunk if it exists.
 *
 * @since 1.0.0
 * @category elements
 */
export declare const last: <A>(self: Chunk<A>) => Option<A>;
/**
 * Builds a `NonEmptyChunk` from an non-empty collection of elements.
 *
 * @since 1.0.0
 * @category constructors
 */
export declare const make: <As extends readonly [any, ...any[]]>(...as: As) => NonEmptyChunk<As[number]>;
/**
 * Builds a `NonEmptyChunk` from a single element.
 *
 * @since 1.0.0
 * @category constructors
 */
export declare const of: <A>(a: A) => NonEmptyChunk<A>;
/**
 * Return a Chunk of length n with element i initialized with f(i).
 *
 * **Note**. `n` is normalized to an integer >= 1.
 *
 * @since 1.0.0
 * @category constructors
 */
export declare const makeBy: {
    <A>(f: (i: number) => A): (n: number) => NonEmptyChunk<A>;
    <A>(n: number, f: (i: number) => A): NonEmptyChunk<A>;
};
/**
 * Returns an effect whose success is mapped by the specified f function.
 *
 * @since 1.0.0
 * @category mapping
 */
export declare const map: {
    <A, B>(f: (a: A) => B): (self: Chunk<A>) => Chunk<B>;
    <A, B>(self: Chunk<A>, f: (a: A) => B): Chunk<B>;
};
/**
 * Returns an effect whose success is mapped by the specified f function.
 *
 * @since 1.0.0
 * @category mapping
 */
export declare const mapWithIndex: {
    <A, B>(f: (a: A, i: number) => B): (self: Chunk<A>) => Chunk<B>;
    <A, B>(self: Chunk<A>, f: (a: A, i: number) => B): Chunk<B>;
};
/**
 * Statefully maps over the chunk, producing new elements of type `B`.
 *
 * @since 1.0.0
 * @category folding
 */
export declare const mapAccum: {
    <S, A, B>(s: S, f: (s: S, a: A) => readonly [S, B]): (self: Chunk<A>) => readonly [S, Chunk<B>];
    <S, A, B>(self: Chunk<A>, s: S, f: (s: S, a: A) => readonly [S, B]): readonly [S, Chunk<B>];
};
/**
 * Separate elements based on a predicate that also exposes the index of the element.
 *
 * @category filtering
 * @since 1.0.0
 */
export declare const partitionWithIndex: {
    <C extends A, B extends A, A = C>(refinement: (a: A, i: number) => a is B): (self: Chunk<C>) => readonly [Chunk<C>, Chunk<B>];
    <B extends A, A = B>(predicate: (a: A, i: number) => boolean): (self: Chunk<B>) => readonly [Chunk<B>, Chunk<B>];
    <C extends A, B extends A, A = C>(self: Chunk<C>, refinement: (a: A, i: number) => a is B): readonly [Chunk<C>, Chunk<B>];
    <B extends A, A = B>(self: Chunk<B>, predicate: (a: A, i: number) => boolean): readonly [Chunk<B>, Chunk<B>];
};
/**
 * Separate elements based on a predicate.
 *
 * @category filtering
 * @since 1.0.0
 */
export declare const partition: {
    <C extends A, B extends A, A = C>(refinement: Refinement<A, B>): (self: Chunk<C>) => readonly [Chunk<C>, Chunk<B>];
    <B extends A, A = B>(predicate: Predicate<A>): (self: Chunk<B>) => readonly [Chunk<B>, Chunk<B>];
    <C extends A, B extends A, A = C>(self: Chunk<C>, refinement: Refinement<A, B>): readonly [Chunk<C>, Chunk<B>];
    <B extends A, A = B>(self: Chunk<B>, predicate: Predicate<A>): readonly [Chunk<B>, Chunk<B>];
};
/**
 * Partitions the elements of this chunk into two chunks using f.
 *
 * @category filtering
 * @since 1.0.0
 */
export declare const partitionMap: {
    <A, B, C>(f: (a: A) => Either<B, C>): (self: Chunk<A>) => readonly [Chunk<B>, Chunk<C>];
    <A, B, C>(self: Chunk<A>, f: (a: A) => Either<B, C>): readonly [Chunk<B>, Chunk<C>];
};
/**
 * Partitions the elements of this chunk into two chunks.
 *
 * @category filtering
 * @since 1.0.0
 */
export declare const separate: <A, B>(self: Chunk<Either<A, B>>) => readonly [Chunk<A>, Chunk<B>];
/**
 * Create a non empty `Chunk` containing a range of integers, including both endpoints.
 *
 * @category constructors
 * @since 1.0.0
 */
export declare const range: (start: number, end: number) => NonEmptyChunk<number>;
/**
 * Reverse a Chunk, creating a new Chunk.
 *
 * @since 1.0.0
 * @category elements
 */
export declare const reverse: <A>(self: Chunk<A>) => Chunk<A>;
/**
 * Retireves the size of the chunk
 *
 * @since 1.0.0
 * @category elements
 */
export declare const size: <A>(self: Chunk<A>) => number;
/**
 * Sort the elements of a Chunk in increasing order, creating a new Chunk.
 *
 * @since 1.0.0
 * @category elements
 */
export declare const sort: {
    <B>(O: Order<B>): <A extends B>(self: Chunk<A>) => Chunk<A>;
    <A extends B, B>(self: Chunk<A>, O: Order<B>): Chunk<A>;
};
/**
 *  Returns two splits of this chunk at the specified index.
 *
 * @since 1.0.0
 * @category elements
 */
export declare const splitAt: {
    (n: number): <A>(self: Chunk<A>) => readonly [Chunk<A>, Chunk<A>];
    <A>(self: Chunk<A>, n: number): readonly [Chunk<A>, Chunk<A>];
};
/**
 * Splits this chunk into `n` equally sized chunks.
 *
 * @since 1.0.0
 * @category elements
 */
export declare const split: {
    (n: number): <A>(self: Chunk<A>) => Chunk<Chunk<A>>;
    <A>(self: Chunk<A>, n: number): Chunk<Chunk<A>>;
};
/**
 * Splits this chunk on the first element that matches this predicate.
 *
 * @since 1.0.0
 * @category elements
 */
export declare const splitWhere: {
    <A>(f: Predicate<A>): (self: Chunk<A>) => readonly [Chunk<A>, Chunk<A>];
    <A>(self: Chunk<A>, f: Predicate<A>): readonly [Chunk<A>, Chunk<A>];
};
/**
 * Returns every elements after the first.
 *
 * @since 1.0.0
 * @category elements
 */
export declare const tail: <A>(self: Chunk<A>) => Option<Chunk<A>>;
/**
 * Takes the last `n` elements.
 *
 * @since 1.0.0
 * @category elements
 */
export declare const takeRight: {
    (n: number): <A>(self: Chunk<A>) => Chunk<A>;
    <A>(self: Chunk<A>, n: number): Chunk<A>;
};
/**
 * Takes all elements so long as the predicate returns true.
 *
 * @since 1.0.0
 * @category elements
 */
export declare const takeWhile: {
    <A>(f: Predicate<A>): (self: Chunk<A>) => Chunk<A>;
    <A>(self: Chunk<A>, f: Predicate<A>): Chunk<A>;
};
/**
 * Constructs a `Chunk` by repeatedly applying the function `f` as long as it * returns `Some`.
 *
 * @since 1.0.0
 * @category elements
 */
export declare const unfold: <A, S>(s: S, f: (s: S) => Option<readonly [A, S]>) => Chunk<A>;
/**
 * Creates a Chunks of unique values, in order, from all given Chunks.
 *
 * @since 1.0.0
 * @category elements
 */
export declare const union: {
    <A>(that: Chunk<A>): <B>(self: Chunk<B>) => Chunk<A | B>;
    <A, B>(self: Chunk<A>, that: Chunk<B>): Chunk<A | B>;
};
/**
 * Remove duplicates from an array, keeping the first occurrence of an element.
 *
 * @since 1.0.0
 * @category elements
 */
export declare const dedupe: <A>(self: Chunk<A>) => Chunk<A>;
/**
 * Returns the first element of this chunk.
 *
 * @since 1.0.0
 * @category unsafe
 */
export declare const unsafeHead: <A>(self: Chunk<A>) => A;
/**
 * Returns the last element of this chunk.
 *
 * @since 1.0.0
 * @category unsafe
 */
export declare const unsafeLast: <A>(self: Chunk<A>) => A;
/**
 * Takes an array of pairs and return two corresponding arrays.
 *
 * Note: The function is reverse of `zip`.
 *
 * @since 1.0.0
 * @category elements
 */
export declare const unzip: <A, B>(as: Chunk<readonly [A, B]>) => readonly [Chunk<A>, Chunk<B>];
/**
 * Zips this chunk pointwise with the specified chunk.
 *
 * @since 1.0.0
 * @category elements
 */
export declare const zip: {
    <B>(that: Chunk<B>): <A>(self: Chunk<A>) => Chunk<readonly [A, B]>;
    <A, B>(self: Chunk<A>, that: Chunk<B>): Chunk<readonly [A, B]>;
};
/**
 * Zips this chunk pointwise with the specified chunk using the specified combiner.
 *
 * @since 1.0.0
 * @category elements
 */
export declare const zipWith: {
    <A, B, C>(that: Chunk<B>, f: (a: A, b: B) => C): (self: Chunk<A>) => Chunk<C>;
    <A, B, C>(self: Chunk<A>, that: Chunk<B>, f: (a: A, b: B) => C): Chunk<C>;
};
/**
 * Zips this chunk pointwise with the specified chunk to produce a new chunk with
 * pairs of elements from each chunk, filling in missing values from the
 * shorter chunk with `None`. The returned chunk will have the length of the
 * longer chunk.
 *
 * @since 1.0.0
 * @category elements
 */
export declare const zipAll: {
    <B>(that: Chunk<B>): <A>(self: Chunk<A>) => Chunk<readonly [Option<A>, Option<B>]>;
    <A, B>(self: Chunk<A>, that: Chunk<B>): Chunk<readonly [Option<A>, Option<B>]>;
};
/**
 * Zips with chunk with the specified chunk to produce a new chunk with
 * pairs of elements from each chunk combined using the specified function
 * `both`. If one chunk is shorter than the other uses the specified
 * function `left` or `right` to map the element that does exist to the
 * result type.
 *
 * @since 1.0.0
 * @category elements
 */
export declare const zipAllWith: {
    <A, B, C, D, E>(that: Chunk<B>, f: (a: A, b: B) => C, left: (a: A) => D, right: (b: B) => E): (self: Chunk<A>) => Chunk<C | D | E>;
    <A, B, C, D, E>(self: Chunk<A>, that: Chunk<B>, f: (a: A, b: B) => C, left: (a: A) => D, right: (b: B) => E): Chunk<C | D | E>;
};
/**
 * Zips this chunk crosswise with the specified chunk using the specified combiner.
 *
 * @since 1.0.0
 * @category elements
 */
export declare const crossWith: {
    <A, B, C>(that: Chunk<B>, f: (a: A, b: B) => C): (self: Chunk<A>) => Chunk<C>;
    <A, B, C>(self: Chunk<A>, that: Chunk<B>, f: (a: A, b: B) => C): Chunk<C>;
};
/**
 * Zips this chunk crosswise with the specified chunk.
 *
 * @since 1.0.0
 * @category elements
 */
export declare const cross: {
    <B>(that: Chunk<B>): <A>(self: Chunk<A>) => Chunk<readonly [A, B]>;
    <A, B>(self: Chunk<A>, that: Chunk<B>): Chunk<readonly [A, B]>;
};
/**
 * Zips this chunk with the index of every element, starting from the initial
 * index value.
 *
 * @category elements
 * @since 1.0.0
 */
export declare const zipWithIndex: <A>(self: Chunk<A>) => Chunk<readonly [A, number]>;
/**
 * Zips this chunk with the index of every element, starting from the initial
 * index value.
 *
 * @category elements
 * @since 1.0.0
 */
export declare const zipWithIndexOffset: {
    (offset: number): <A>(self: Chunk<A>) => Chunk<[A, number]>;
    <A>(self: Chunk<A>, offset: number): Chunk<[A, number]>;
};
/**
 * Delete the element at the specified index, creating a new `Chunk`,
 * or returning the input if the index is out of bounds.
 *
 * @category mutations
 * @since 1.0.0
 */
export declare const remove: {
    (i: number): <A>(self: Chunk<A>) => Chunk<A>;
    <A>(self: Chunk<A>, i: number): Chunk<A>;
};
/**
 * Change the element at the specified index, creating a new `Chunk`,
 * or returning the input if the index is out of bounds.
 *
 * @category mutations
 * @since 1.0.0
 */
export declare const replace: {
    <B>(i: number, b: B): <A>(self: Chunk<A>) => Chunk<B | A>;
    <A, B>(self: Chunk<A>, i: number, b: B): Chunk<B | A>;
};
/**
 * @category mutations
 * @since 1.0.0
 */
export declare const replaceOption: {
    <B>(i: number, b: B): <A>(self: Chunk<A>) => Option<Chunk<B | A>>;
    <A, B>(self: Chunk<A>, i: number, b: B): Option<Chunk<B | A>>;
};
/**
 * Apply a function to the element at the specified index, creating a new `Chunk`,
 * or returning the input if the index is out of bounds.
 *
 * @category mutations
 * @since 1.0.0
 */
export declare const modify: {
    <A, B>(i: number, f: (a: A) => B): (self: Chunk<A>) => Chunk<A | B>;
    <A, B>(self: Chunk<A>, i: number, f: (a: A) => B): Chunk<A | B>;
};
/**
 * @category mutations
 * @since 1.0.0
 */
export declare const modifyOption: {
    <A, B>(i: number, f: (a: A) => B): (self: Chunk<A>) => Option<Chunk<A | B>>;
    <A, B>(self: Chunk<A>, i: number, f: (a: A) => B): Option<Chunk<A | B>>;
};
/**
 * Returns the first element of this non empty chunk.
 *
 * @since 1.0.0
 * @category elements
 */
export declare const headNonEmpty: <A>(self: NonEmptyChunk<A>) => A;
/**
 * Returns every elements after the first.
 *
 * @since 1.0.0
 * @category elements
 */
export declare const tailNonEmpty: <A>(self: NonEmptyChunk<A>) => Chunk<A>;
export {};
//# sourceMappingURL=Chunk.d.ts.map